{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar extend = require(\"extend\");\n\nvar fileType = require(\"file-type\");\n\nvar isstream_1 = require(\"isstream\");\n\nvar mime_types_1 = require(\"mime-types\");\n\nvar path_1 = require(\"path\");\n\nvar logger_1 = require(\"./logger\"); // custom type guards\n\n\nfunction isFileObject(obj) {\n  return Boolean(obj && obj.value);\n}\n\nfunction isFileStream(obj) {\n  return Boolean(obj && isstream_1.isReadable(obj) && obj.path);\n}\n\nfunction isFileWithMetadata(obj) {\n  return Boolean(obj && obj.data && isFileData(obj.data));\n}\n\nexports.isFileWithMetadata = isFileWithMetadata;\n\nfunction isFileData(obj) {\n  return Boolean(obj && (isstream_1.isReadable(obj) || Buffer.isBuffer(obj)));\n}\n\nexports.isFileData = isFileData;\n\nfunction isEmptyObject(obj) {\n  return Boolean(obj && Object.keys(obj).length === 0 && obj.constructor === Object);\n}\n\nexports.isEmptyObject = isEmptyObject;\n/**\n * This function retrieves the content type of the input.\n * @param {NodeJS.ReadableStream|Buffer} inputData - The data to retrieve content type for.\n * @returns {string} the content type of the input.\n */\n\nfunction getContentType(inputData) {\n  var contentType = null;\n\n  if (isFileStream(inputData)) {\n    // if the inputData is a NodeJS.ReadableStream\n    var mimeType = mime_types_1.lookup(inputData.path);\n    contentType = {\n      mime: mimeType || null\n    };\n  } else if (Buffer.isBuffer(inputData)) {\n    // if the inputData is a Buffer\n    contentType = fileType(inputData);\n  }\n\n  return contentType ? contentType.mime : null;\n}\n\nexports.getContentType = getContentType;\n/**\n *\n * @param {string} url - the url string.\n * @returns {string}\n */\n\nfunction stripTrailingSlash(url) {\n  // Match a forward slash / at the end of the string ($)\n  return url.replace(/\\/$/, '');\n}\n\nexports.stripTrailingSlash = stripTrailingSlash;\n/**\n * Validates that all required params are provided\n * @param params - the method parameters.\n * @param requires - the required parameter names.\n * @returns {Error|null}\n */\n\nfunction getMissingParams(params, requires) {\n  var missing;\n\n  if (!requires) {\n    return null;\n  } else if (!params) {\n    missing = requires;\n  } else {\n    missing = [];\n    requires.forEach(function (require) {\n      if (!params[require]) {\n        missing.push(require);\n      }\n    });\n  }\n\n  return missing.length > 0 ? new Error('Missing required parameters: ' + missing.join(', ')) : null;\n}\n\nexports.getMissingParams = getMissingParams;\n/**\n * Return true if 'text' is html\n * @param  {string} text - The 'text' to analyze\n * @returns {boolean} true if 'text' has html tags\n */\n\nfunction isHTML(text) {\n  logger_1.default.debug(\"Determining if the text \" + text + \" is HTML.\");\n  return /<[a-z][\\s\\S]*>/i.test(text);\n}\n\nexports.isHTML = isHTML;\n/**\n * Returns the first match from formats that is key the params map\n * otherwise null\n * @param  {Object} params - The parameters.\n * @param  {string[]} requires - The keys we want to check\n * @returns {string|null}\n */\n\nfunction getFormat(params, formats) {\n  if (!formats || !params) {\n    logger_1.default.debug(\"No formats to parse in getFormat. Returning null\");\n    return null;\n  }\n\n  for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {\n    var item = formats_1[_i];\n\n    if (item in params) {\n      return item;\n    }\n  }\n\n  logger_1.default.debug(\"No formats to parse in getFormat. Returning null\");\n  return null;\n}\n\nexports.getFormat = getFormat;\n/**\n * this function builds a `form-data` object for each file parameter\n * @param {FileWithMetadata} fileParam - the file parameter\n * @param {NodeJS.ReadableStream|Buffer} fileParam.data - the data content of the file\n * @param (string) fileParam.filename - the filename of the file\n * @param {string} fileParam.contentType - the content type of the file\n * @returns {FileObject}\n */\n\nfunction buildRequestFileObject(fileParam) {\n  var fileObj;\n\n  if (isFileObject(fileParam.data)) {\n    // For backward compatibility, we allow the data to be a FileObject.\n    fileObj = {\n      value: fileParam.data.value,\n      options: {}\n    };\n\n    if (fileParam.data.options) {\n      fileObj.options = {\n        filename: fileParam.filename || fileParam.data.options.filename,\n        contentType: fileParam.contentType || fileParam.data.options.contentType\n      };\n    }\n  } else {\n    fileObj = {\n      value: fileParam.data,\n      options: {\n        filename: fileParam.filename,\n        contentType: fileParam.contentType\n      }\n    };\n  } // Also for backward compatibility, we allow data to be a string\n\n\n  if (typeof fileObj.value === 'string') {\n    fileObj.value = Buffer.from(fileObj.value);\n  } // build filename\n\n\n  var filename = fileObj.options.filename;\n\n  if (!filename && isFileStream(fileObj.value)) {\n    // if readable stream with path property\n    filename = fileObj.value.path;\n  } // toString handles the case when path is a buffer\n\n\n  fileObj.options.filename = filename ? path_1.basename(filename.toString()) : '_'; // build contentType\n\n  if (!fileObj.options.contentType && isFileData(fileObj.value)) {\n    fileObj.options.contentType = getContentType(fileObj.value) || 'application/octet-stream';\n  }\n\n  return fileObj;\n}\n\nexports.buildRequestFileObject = buildRequestFileObject;\n/**\n * this function converts an object's keys to lower case\n * note: does not convert nested keys\n * @param {Object} obj - the object to convert the keys of\n * @returns {Object}\n */\n\nfunction toLowerKeys(obj) {\n  var _obj = {};\n\n  if (obj) {\n    _obj = extend.apply(void 0, __spreadArrays([{}], Object.keys(obj).map(function (key) {\n      var _a;\n\n      return _a = {}, _a[key.toLowerCase()] = obj[key], _a;\n    })));\n  }\n\n  return _obj;\n}\n\nexports.toLowerKeys = toLowerKeys;","map":null,"metadata":{},"sourceType":"script"}