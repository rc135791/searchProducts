{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2019 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar extend = require(\"extend\");\n\nvar jwt = require(\"jsonwebtoken\");\n\nvar logger_1 = require(\"../../lib/logger\");\n\nvar request_wrapper_1 = require(\"../../lib/request-wrapper\");\n\nfunction getCurrentTime() {\n  return Math.floor(Date.now() / 1000);\n}\n\nvar JwtTokenManager =\n/** @class */\nfunction () {\n  /**\n   * Token Manager Service\n   *\n   * Retreives and stores JSON web tokens.\n   *\n   * @param {Object} options\n   * @param {String} options.url - url of the api to retrieve tokens from\n   * @param {String} [options.accessToken] - user-managed access token\n   * @constructor\n   */\n  function JwtTokenManager(options) {\n    // all parameters are optional\n    options = options || {};\n    this.tokenInfo = {};\n    this.tokenName = 'access_token';\n\n    if (options.url) {\n      this.url = options.url;\n    } // request options\n\n\n    this.disableSslVerification = Boolean(options.disableSslVerification);\n    this.headers = options.headers || {}; // any config options for the internal request library, like `proxy`, will be passed here\n\n    this.requestWrapperInstance = new request_wrapper_1.RequestWrapper(options);\n  }\n  /**\n   * This function returns a Promise that resolves with an access token, if successful.\n   * The source of the token is determined by the following logic:\n   * 1. If user provides their own managed access token, assume it is valid and send it\n   * 2. a) If this class is managing tokens and does not yet have one, make a request for one\n   *    b) If this class is managing tokens and the token has expired, request a new one\n   * 3. If this class is managing tokens and has a valid token stored, send it\n   *\n   */\n\n\n  JwtTokenManager.prototype.getToken = function () {\n    var _this = this;\n\n    if (!this.tokenInfo[this.tokenName] || this.isTokenExpired()) {\n      // 1. request a new token\n      return this.requestToken().then(function (tokenResponse) {\n        _this.saveTokenInfo(tokenResponse.result);\n\n        return _this.tokenInfo[_this.tokenName];\n      });\n    } else {\n      // 2. use valid, managed token\n      return Promise.resolve(this.tokenInfo[this.tokenName]);\n    }\n  };\n  /**\n   * Setter for the disableSslVerification property.\n   *\n   * @param {boolean} value - the new value for the disableSslVerification property\n   * @returns {void}\n   */\n\n\n  JwtTokenManager.prototype.setDisableSslVerification = function (value) {\n    // if they try to pass in a non-boolean value,\n    // use the \"truthy-ness\" of the value\n    this.disableSslVerification = Boolean(value);\n  };\n  /**\n   * Set a completely new set of headers.\n   *\n   * @param {OutgoingHttpHeaders} headers - the new set of headers as an object\n   * @returns {void}\n   */\n\n\n  JwtTokenManager.prototype.setHeaders = function (headers) {\n    if (typeof headers !== 'object') {\n      // do nothing, for now\n      return;\n    }\n\n    this.headers = headers;\n  };\n  /**\n   * Request a JWT using an API key.\n   *\n   * @returns {Promise}\n   */\n\n\n  JwtTokenManager.prototype.requestToken = function () {\n    var errMsg = '`requestToken` MUST be overridden by a subclass of JwtTokenManagerV1.';\n    var err = new Error(errMsg);\n    logger_1.default.error(errMsg);\n    return Promise.reject(err);\n  };\n  /**\n   * Check if currently stored token is \"expired\"\n   * i.e. past the window to request a new token\n   *\n   * @private\n   * @returns {boolean}\n   */\n\n\n  JwtTokenManager.prototype.isTokenExpired = function () {\n    var expireTime = this.expireTime;\n\n    if (!expireTime) {\n      return true;\n    }\n\n    var currentTime = getCurrentTime();\n    return expireTime < currentTime;\n  };\n  /**\n   * Save the JWT service response and the calculated expiration time to the object's state.\n   *\n   * @param tokenResponse - Response object from JWT service request\n   * @private\n   * @returns {void}\n   */\n\n\n  JwtTokenManager.prototype.saveTokenInfo = function (tokenResponse) {\n    var accessToken = tokenResponse[this.tokenName];\n\n    if (!accessToken) {\n      var err = 'Access token not present in response';\n      logger_1.default.error(err);\n      throw new Error(err);\n    }\n\n    this.expireTime = this.calculateTimeForNewToken(accessToken);\n    this.tokenInfo = extend({}, tokenResponse);\n  };\n  /**\n   * Decode the access token and calculate the time to request a new token.\n   *\n   * A time buffer prevents the edge case of the token expiring before the request could be made.\n   * The buffer will be a fraction of the total time to live - we are using 80%\n   *\n   * @param accessToken - JSON Web Token received from the service\n   * @private\n   * @returns {void}\n   */\n\n\n  JwtTokenManager.prototype.calculateTimeForNewToken = function (accessToken) {\n    // the time of expiration is found by decoding the JWT access token\n    // exp is the time of expire and iat is the time of token retrieval\n    var timeForNewToken;\n    var decodedResponse = jwt.decode(accessToken);\n\n    if (decodedResponse) {\n      var exp = decodedResponse.exp,\n          iat = decodedResponse.iat;\n      var fractionOfTtl = 0.8;\n      var timeToLive = exp - iat;\n      timeForNewToken = exp - timeToLive * (1.0 - fractionOfTtl);\n    } else {\n      var err = 'Access token recieved is not a valid JWT';\n      logger_1.default.error(err);\n      throw new Error(err);\n    }\n\n    return timeForNewToken;\n  };\n\n  return JwtTokenManager;\n}();\n\nexports.JwtTokenManager = JwtTokenManager;","map":null,"metadata":{},"sourceType":"script"}