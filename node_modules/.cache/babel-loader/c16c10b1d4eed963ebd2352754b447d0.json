{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar extend = require(\"extend\");\n\nvar auth_1 = require(\"../auth\");\n\nvar helper_1 = require(\"./helper\");\n\nvar logger_1 = require(\"./logger\");\n\nvar request_wrapper_1 = require(\"./request-wrapper\");\n\nvar BaseService =\n/** @class */\nfunction () {\n  /**\n   * Internal base class that other services inherit from\n   * @param {UserOptions} options\n   * @param {OutgoingHttpHeaders} [options.headers]\n   * @param {string} [options.url] - override default service base url\n   * @private\n   * @abstract\n   * @constructor\n   * @throws {Error}\n   * @returns {BaseService}\n   */\n  function BaseService(userOptions) {\n    if (!(this instanceof BaseService)) {\n      var err = 'the \"new\" keyword is required to create service instances';\n      logger_1.default.error(\"Error creating an instance of BaseService: \" + err);\n      throw new Error(err);\n    }\n\n    var _options = {};\n    var options = extend({}, userOptions); // for compatibility\n\n    if (options.url && !options.serviceUrl) {\n      options.serviceUrl = options.url;\n    }\n\n    if (options.serviceUrl) {\n      _options.serviceUrl = helper_1.stripTrailingSlash(options.serviceUrl);\n    } // check serviceUrl for common user errors\n\n\n    var credentialProblems = auth_1.checkCredentials(options, ['serviceUrl']);\n\n    if (credentialProblems) {\n      logger_1.default.error(credentialProblems.message);\n      throw credentialProblems;\n    } // if disableSslVerification is not explicity set to the boolean value `true`,\n    // force it to be false\n\n\n    if (options.disableSslVerification !== true) {\n      options.disableSslVerification = false;\n    }\n\n    var serviceClass = this.constructor;\n    this.baseOptions = extend({\n      qs: {},\n      serviceUrl: serviceClass.URL\n    }, options, _options);\n    this.requestWrapperInstance = new request_wrapper_1.RequestWrapper(this.baseOptions); // enforce that an authenticator is set\n\n    if (!options.authenticator) {\n      throw new Error('Authenticator must be set.');\n    }\n\n    this.authenticator = options.authenticator; // temp: call the configureService method to ensure compatibility\n\n    this.configureService(this.name);\n  }\n  /**\n   * Get the instance of the authenticator set on the service.\n   *\n   * @returns {Authenticator}\n   */\n\n\n  BaseService.prototype.getAuthenticator = function () {\n    return this.authenticator;\n  };\n  /**\n   * Set the service URL to send requests to.\n   *\n   * @param {string} the base URL for the service\n   */\n\n\n  BaseService.prototype.setServiceUrl = function (url) {\n    this.baseOptions.serviceUrl = url;\n  };\n  /**\n   * Configure the service using external configuration\n   *\n   * @param {string} the name of the service. Will be used to read from external\n   * configuration\n   */\n\n\n  BaseService.prototype.configureService = function (serviceName) {\n    if (!serviceName) {\n      var err = 'Error configuring service. Service name is required.';\n      logger_1.default.error(err);\n      throw new Error(err);\n    }\n\n    extend(this.baseOptions, this.readOptionsFromExternalConfig(serviceName)); // overwrite the requestWrapperInstance with the new base options if applicable\n\n    this.requestWrapperInstance = new request_wrapper_1.RequestWrapper(this.baseOptions);\n  };\n  /**\n   * Wrapper around `sendRequest` that enforces the request will be authenticated.\n   *\n   * @param {object} parameters - service request options passed in by user\n   * @param {string} parameters.options.method - the http method\n   * @param {string} parameters.options.url - the path portion of the URL to be appended to the serviceUr\n   * @param {object} [parameters.options.path] - the path parameters to be inserted into the URL\n   * @param {object} [parameters.options.qs] - the querystring to be included in the URL\n   * @param {object} [parameters.options.body] - the data to be sent as the request body\n   * @param {object} [parameters.options.form] - an object containing the key/value pairs for a www-form-urlencoded request\n   * @param {object} [parameters.options.formData] - an object containing the contents for a multipart/form-data request\n   * The following processing is performed on formData values:\n   * - string: no special processing -- the value is sent as is\n   * - object: the value is converted to a JSON string before insertion into the form body\n   * - NodeJS.ReadableStream|Buffer|FileWithMetadata: sent as a file, with any associated metadata\n   * - array: each element of the array is sent as a separate form part using any special processing as described above\n   * @param {object} parameters.defaultOptions\n   * @param {string} parameters.defaultOptions.serviceUrl - the base URL of the service\n   * @param {OutgoingHttpHeaders} parameters.defaultOptions.headers - additional headers to be passed on the request\n   * @returns {Promise<any>}\n   */\n\n\n  BaseService.prototype.createRequest = function (parameters) {\n    var _this = this; // validate serviceUrl parameter has been set\n\n\n    var serviceUrl = parameters.defaultOptions && parameters.defaultOptions.serviceUrl;\n\n    if (!serviceUrl || typeof serviceUrl !== 'string') {\n      return Promise.reject(new Error('The service URL is required'));\n    }\n\n    return this.authenticator.authenticate(parameters.defaultOptions).then(function () {\n      // resolve() handles rejection as well, so resolving the result of sendRequest should allow for proper handling later\n      return _this.requestWrapperInstance.sendRequest(parameters);\n    });\n  };\n\n  BaseService.prototype.readOptionsFromExternalConfig = function (serviceName) {\n    var results = {};\n    var properties = auth_1.readExternalSources(serviceName);\n\n    if (properties !== null) {\n      // the user can define two client-level variables in the credentials file: url and disableSsl\n      var url = properties.url,\n          disableSsl = properties.disableSsl;\n\n      if (url) {\n        results.serviceUrl = url;\n      }\n\n      if (disableSsl === true) {\n        results.disableSslVerification = disableSsl;\n      }\n    }\n\n    return results;\n  };\n\n  return BaseService;\n}();\n\nexports.BaseService = BaseService;","map":null,"metadata":{},"sourceType":"script"}