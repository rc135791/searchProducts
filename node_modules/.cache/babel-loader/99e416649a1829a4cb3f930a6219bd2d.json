{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2014 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar axios_1 = require(\"axios\");\n\nvar extend = require(\"extend\");\n\nvar FormData = require(\"form-data\");\n\nvar https = require(\"https\");\n\nvar querystring = require(\"querystring\");\n\nvar helper_1 = require(\"./helper\");\n\nvar logger_1 = require(\"./logger\");\n\nvar isBrowser = typeof window === 'object';\nvar globalTransactionId = 'x-global-transaction-id'; // Limit the type of axios configs to be customizable\n\nvar allowedAxiosConfig = ['transformRequest', 'transformResponse', 'paramsSerializer', 'paramsSerializer', 'timeout', 'withCredentials', 'adapter', 'responseType', 'responseEncoding', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength', 'validateStatus', 'maxRedirects', 'socketPath', 'httpAgent', 'httpsAgent', 'proxy', 'cancelToken'];\n\nvar RequestWrapper =\n/** @class */\nfunction () {\n  function RequestWrapper(axiosOptions) {\n    axiosOptions = axiosOptions || {}; // override several axios defaults\n    // axios sets the default Content-Type for `post`, `put`, and `patch` operations\n    // to 'application/x-www-form-urlencoded'. This causes problems, so overriding the\n    // defaults here\n\n    var axiosConfig = {\n      httpsAgent: new https.Agent({\n        // disableSslVerification is the parameter we expose to the user,\n        // it is the opposite of rejectUnauthorized\n        rejectUnauthorized: !axiosOptions.disableSslVerification\n      }),\n      maxContentLength: Infinity,\n      headers: {\n        post: {\n          'Content-Type': 'application/json'\n        },\n        put: {\n          'Content-Type': 'application/json'\n        },\n        patch: {\n          'Content-Type': 'application/json'\n        }\n      }\n    }; // merge valid Axios Config into default.\n\n    extend(true, axiosConfig, allowedAxiosConfig.reduce(function (reducedConfig, key) {\n      reducedConfig[key] = axiosOptions[key];\n      return reducedConfig;\n    }, {}));\n    this.axiosInstance = axios_1.default.create(axiosConfig); // set debug interceptors\n\n    if (process.env.NODE_DEBUG === 'axios' || process.env.DEBUG) {\n      this.axiosInstance.interceptors.request.use(function (config) {\n        logger_1.default.debug('Request:');\n\n        try {\n          logger_1.default.debug(JSON.stringify(config, null, 2));\n        } catch (_a) {\n          logger_1.default.error(config);\n        }\n\n        return config;\n      }, function (error) {\n        logger_1.default.error('Error: ');\n\n        try {\n          logger_1.default.error(JSON.stringify(error, null, 2));\n        } catch (_a) {\n          logger_1.default.error(error);\n        }\n\n        return Promise.reject(error);\n      });\n      this.axiosInstance.interceptors.response.use(function (response) {\n        logger_1.default.debug('Response:');\n\n        try {\n          logger_1.default.debug(JSON.stringify(response, null, 2));\n        } catch (_a) {\n          logger_1.default.error(response);\n        }\n\n        return response;\n      }, function (error) {\n        logger_1.default.error('Error: ');\n\n        try {\n          logger_1.default.error(JSON.stringify(error, null, 2));\n        } catch (_a) {\n          logger_1.default.error(error);\n        }\n\n        return Promise.reject(error);\n      });\n    }\n  }\n  /**\n   * Creates the request.\n   * 1. Merge default options with user provided options\n   * 2. Checks for missing parameters\n   * 3. Encode path and query parameters\n   * 4. Call the api\n   * @private\n   * @returns {ReadableStream|undefined}\n   * @throws {Error}\n   */\n\n\n  RequestWrapper.prototype.sendRequest = function (parameters) {\n    var _this = this;\n\n    var options = extend(true, {}, parameters.defaultOptions, parameters.options);\n    var path = options.path,\n        body = options.body,\n        form = options.form,\n        formData = options.formData,\n        qs = options.qs,\n        method = options.method,\n        serviceUrl = options.serviceUrl;\n    var headers = options.headers,\n        url = options.url;\n    var multipartForm = new FormData(); // Form params\n\n    if (formData) {\n      Object.keys(formData).forEach(function (key) {\n        var values = Array.isArray(formData[key]) ? formData[key] : [formData[key]]; // Skip keys with undefined/null values or empty object value\n\n        values.filter(function (v) {\n          return v != null && !helper_1.isEmptyObject(v);\n        }).forEach(function (value) {\n          // Special case of empty file object\n          if (value.hasOwnProperty('contentType') && !value.hasOwnProperty('data')) {\n            return;\n          }\n\n          if (helper_1.isFileWithMetadata(value)) {\n            var fileObj = helper_1.buildRequestFileObject(value);\n            multipartForm.append(key, fileObj.value, fileObj.options);\n          } else {\n            if (typeof value === 'object' && !helper_1.isFileData(value)) {\n              value = JSON.stringify(value);\n            }\n\n            multipartForm.append(key, value);\n          }\n        });\n      });\n    } // Path params\n\n\n    url = parsePath(url, path); // Headers\n\n    options.headers = extend({}, options.headers); // Convert array-valued query params to strings\n\n    if (qs && Object.keys(qs).length > 0) {\n      Object.keys(qs).forEach(function (key) {\n        return Array.isArray(qs[key]) && (qs[key] = qs[key].join(','));\n      });\n    } // Add service default endpoint if options.url start with /\n\n\n    if (url && url.charAt(0) === '/') {\n      url = serviceUrl + url;\n    }\n\n    var data = body;\n\n    if (form) {\n      data = querystring.stringify(form);\n      headers['Content-type'] = 'application/x-www-form-urlencoded';\n    }\n\n    if (formData) {\n      data = multipartForm; // form-data generates headers that MUST be included or the request will fail\n\n      headers = extend(true, {}, headers, multipartForm.getHeaders());\n    } // TEMPORARY: Disabling gzipping due to bug in axios until fix is released:\n    // https://github.com/axios/axios/pull/1129\n    // accept gzip encoded responses if Accept-Encoding is not already set\n    // headers['Accept-Encoding'] = headers['Accept-Encoding'] || 'gzip';\n\n\n    var requestParams = {\n      url: url,\n      method: method,\n      headers: headers,\n      params: qs,\n      data: data,\n      responseType: options.responseType || 'json',\n      paramsSerializer: function paramsSerializer(params) {\n        return querystring.stringify(params);\n      }\n    };\n    return this.axiosInstance(requestParams).then(function (res) {\n      // sometimes error responses will still trigger the `then` block - escape that behavior here\n      if (!res) {\n        return;\n      }\n\n      ; // these objects contain circular json structures and are not always relevant to the user\n      // if the user wants them, they can be accessed through the debug properties\n\n      delete res.config;\n      delete res.request; // the other sdks use the interface `result` for the body\n\n      res.result = res.data;\n      delete res.data; // return another promise that resolves with 'res' to be handled in generated code\n\n      return res;\n    }, function (err) {\n      // return another promise that rejects with 'err' to be handled in generated code\n      throw _this.formatError(err);\n    });\n  };\n  /**\n   * Format error returned by axios\n   * @param  {object} the object returned by axios via rejection\n   * @private\n   * @returns {Error}\n   */\n\n\n  RequestWrapper.prototype.formatError = function (axiosError) {\n    // return an actual error object,\n    // but make it flexible so we can add properties like 'body'\n    var error = new Error(); // axios specific handling\n    // this branch is for an error received from the service\n\n    if (axiosError.response) {\n      axiosError = axiosError.response; // The request was made and the server responded with a status code\n      // that falls out of the range of 2xx\n\n      delete axiosError.config;\n      delete axiosError.request;\n      error.name = axiosError.statusText;\n      error.code = axiosError.status;\n      error.message = parseServiceErrorMessage(axiosError.data) || axiosError.statusText; // some services bury the useful error message within 'data'\n      // adding it to the error under the key 'body' as a string or object\n\n      var errorBody = void 0;\n\n      try {\n        // try/catch to handle objects with circular references\n        errorBody = JSON.stringify(axiosError.data);\n      } catch (e) {\n        // ignore the error, use the object, and tack on a warning\n        errorBody = axiosError.data;\n        errorBody.warning = 'Body contains circular reference';\n        logger_1.default.error(\"Failed to stringify axiosError: \" + e);\n      }\n\n      error.body = errorBody; // attach headers to error object\n\n      error.headers = axiosError.headers; // print a more descriptive error message for auth issues\n\n      if (isAuthenticationError(axiosError)) {\n        error.message = 'Access is denied due to invalid credentials.';\n      }\n    } else if (axiosError.request) {\n      // The request was made but no response was received\n      // `error.request` is an instance of XMLHttpRequest in the browser and an instance of\n      // http.ClientRequest in node.js\n      error.message = axiosError.message;\n      error.statusText = axiosError.code;\n      error.body = 'Response not received - no connection was made to the service.'; // when a request to a private cloud instance has an ssl problem, it never connects and follows this branch of the error handling\n\n      if (isSelfSignedCertificateError(axiosError)) {\n        error.message = \"The connection failed because the SSL certificate is not valid. \" + \"To use a self-signed certificate, set the `disableSslVerification` parameter in the constructor options.\";\n      }\n    } else {\n      // Something happened in setting up the request that triggered an Error\n      error.message = axiosError.message;\n    }\n\n    return error;\n  };\n\n  return RequestWrapper;\n}();\n\nexports.RequestWrapper = RequestWrapper;\n/**\n * @private\n * @param {string} path\n * @param {Object} params\n * @returns {string}\n */\n\nfunction parsePath(path, params) {\n  if (!path || !params) {\n    return path;\n  }\n\n  return Object.keys(params).reduce(function (parsedPath, param) {\n    var value = encodeURIComponent(params[param]);\n    return parsedPath.replace(new RegExp(\"{\" + param + \"}\"), value);\n  }, path);\n}\n/**\n * Determine if the error is due to bad credentials\n * @private\n * @param {Object} error - error object returned from axios\n * @returns {boolean} true if error is due to authentication\n */\n\n\nfunction isAuthenticationError(error) {\n  var isAuthErr = false;\n  var code = error.status || null;\n  var body = error.data || {}; // handle specific error from iam service, should be relevant across platforms\n\n  var isIamServiceError = body.context && body.context.url && body.context.url.indexOf('iam') > -1;\n\n  if (code === 401 || code === 403 || isIamServiceError) {\n    isAuthErr = true;\n  }\n\n  return isAuthErr;\n}\n/**\n * Determine if the error is due to a bad self signed certificate\n * @private\n * @param {Object} error - error object returned from axios\n * @returns {boolean} true if error is due to an SSL error\n */\n\n\nfunction isSelfSignedCertificateError(error) {\n  var result = false;\n  var sslCode = 'DEPTH_ZERO_SELF_SIGNED_CERT';\n  var sslMessage = 'self signed certificate';\n  var hasSslCode = error.code === sslCode;\n  var hasSslMessage = hasStringProperty(error, 'message') && error.message.includes(sslMessage);\n\n  if (hasSslCode || hasSslMessage) {\n    result = true;\n  }\n\n  return result;\n}\n/**\n * Return true if object has a specified property that is a string\n * @private\n * @param {Object} obj - object to look for property in\n * @param {string} property - name of the property to look for\n * @returns {boolean} true if property exists and is string\n */\n\n\nfunction hasStringProperty(obj, property) {\n  return Boolean(obj[property] && typeof obj[property] === 'string');\n}\n/**\n * Look for service error message in common places, by priority\n * first look in `errors[0].message`, then in `error`, then in\n * `message`, then in `errorMessage`\n * @private\n * @param {Object} response - error response body received from service\n * @returns {string | undefined} the error message if is was found, undefined otherwise\n */\n\n\nfunction parseServiceErrorMessage(response) {\n  var message;\n\n  if (Array.isArray(response.errors) && response.errors.length > 0 && hasStringProperty(response.errors[0], 'message')) {\n    message = response.errors[0].message;\n  } else if (hasStringProperty(response, 'error')) {\n    message = response.error;\n  } else if (hasStringProperty(response, 'message')) {\n    message = response.message;\n  } else if (hasStringProperty(response, 'errorMessage')) {\n    message = response.errorMessage;\n  }\n\n  logger_1.default.info(\"Parsing service error message: \" + message);\n  return message;\n}","map":null,"metadata":{},"sourceType":"script"}