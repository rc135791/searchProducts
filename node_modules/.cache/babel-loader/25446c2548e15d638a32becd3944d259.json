{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar async = require(\"async\");\n\nvar extend = require(\"extend\");\n\nvar isStream = require(\"isstream\");\n\nvar common_1 = require(\"../lib/common\");\n\nvar RecognizeStream = require(\"../lib/recognize-stream\");\n\nvar GeneratedSpeechToTextV1 = require(\"./v1-generated\");\n/**\n * Check if there is a corpus that is still being processed\n * @private\n * @param corporaList\n * @return {boolean}\n */\n\n\nfunction isProcessing(corporaList) {\n  return corporaList.corpora.some(function (record) {\n    return record['status'] === 'being_processed';\n  });\n}\n/**\n * Check if corpora has been analyzed\n * @private\n * @param corporaList\n * @return {boolean}\n */\n\n\nfunction isAnalyzed(corporaList) {\n  return corporaList.corpora.some(function (record) {\n    return record['status'] === 'analyzed';\n  });\n}\n\nvar SpeechToTextV1 =\n/** @class */\nfunction (_super) {\n  __extends(SpeechToTextV1, _super);\n\n  function SpeechToTextV1(options) {\n    return _super.call(this, options) || this;\n  }\n  /**\n   * Waits while corpora analysis status is 'being_processes', fires callback once the status is 'analyzed'\n   *\n   * Note: the code will throw an error in case there in no corpus in the customization\n   *\n   *\n   * @param {Object} params The parameters\n   * @param {String} params.customization_id - The GUID of the custom language model\n   * @param {Number} [params.interval=5000] - (milliseconds) - how long to wait between status checks\n   * @param {Number} [params.times=30] - maximum number of attempts\n   * @param {Function} callback\n   */\n\n\n  SpeechToTextV1.prototype.whenCorporaAnalyzed = function (params, callback) {\n    var self = this;\n    async.parallel([// validate that it has at least one corpus\n    function (next) {\n      self.listCorpora(params, function (err, res) {\n        var result = res.result;\n\n        if (err) {\n          return next(err);\n        }\n\n        if (!result.corpora.length) {\n          var sttError = new Error('Customization has no corpa and therefore corpus cannot be analyzed');\n          sttError.code = SpeechToTextV1.ERR_NO_CORPORA;\n          return next(sttError);\n        }\n\n        next(null);\n      });\n    }, // check the customization status repeatedly until it's available\n    function (next) {\n      var options = extend({\n        interval: 5000,\n        times: 30\n      }, params, {\n        errorFilter: function errorFilter(err) {\n          // if it's a timeout error, then listCorpora is called again after params.interval\n          // otherwise the error is passed back to the user\n          // if the params.times limit is reached, the error will be passed to the user regardless\n          return err.code === SpeechToTextV1.ERR_TIMEOUT;\n        }\n      });\n      async.retry(options, function (done) {\n        self.listCorpora(params, function (err, res) {\n          var corpora = res.result;\n\n          if (err) {\n            done(err);\n          } else if (corpora !== undefined && isProcessing(corpora)) {\n            // if the loop times out, async returns the last error, which will be this one.\n            var sttError = new Error('Corpora is still being processed, try increasing interval or times params');\n            sttError.code = SpeechToTextV1.ERR_TIMEOUT;\n            done(sttError);\n          } else if (corpora !== undefined && isAnalyzed(corpora)) {\n            done(null, corpora);\n          } else {\n            done(new Error('Unexpected corpus analysis status'));\n          }\n        });\n      }, next);\n    }], function (err, res) {\n      var result = res;\n\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, result[1]); // callback with the final customization object\n    });\n  };\n\n  SpeechToTextV1.prototype.recognizeUsingWebSocket = function (params) {\n    var streamParams = extend(params, {}, {\n      // pass the Authenticator to the RecognizeStream object\n      authenticator: this.getAuthenticator(),\n      url: this.baseOptions.url,\n      // if the user configured a custom https client, use it in the websocket method\n      // let httpsAgent take precedence, default to null\n      agent: this.baseOptions.httpsAgent || this.baseOptions.httpAgent || null,\n      // allow user to disable ssl verification when using websockets\n      disableSslVerification: this.baseOptions.disableSslVerification\n    }); // include analytics headers\n\n    var sdkHeaders = common_1.getSdkHeaders('speech_to_text', 'v1', 'recognizeUsingWebSocket');\n    streamParams.headers = extend(true, sdkHeaders, streamParams.headers);\n    return new RecognizeStream(streamParams);\n  };\n\n  SpeechToTextV1.prototype.recognize = function (params, callback) {\n    if (params && params.audio && isStream(params.audio) && !params.contentType) {\n      callback(new Error('If providing `audio` as a Stream, `contentType` is required.'));\n      return;\n    }\n\n    return _super.prototype.recognize.call(this, params, callback);\n  };\n  /**\n   * Waits while a customization status is 'pending' or 'training', fires callback once the status is 'ready' or 'available'.\n   *\n   * Note: the customization will remain in 'pending' status until at least one word corpus is added.\n   *\n   * See http://www.ibm.com/watson/developercloud/speech-to-text/api/v1/#list_models for status details.\n   *\n   * @param {Object} params The parameters\n   * @param {String} params.customization_id - The GUID of the custom language model\n   * @param {Number} [params.interval=5000] - (milliseconds) - how log to wait between status checks\n   * @param {Number} [params.times=30] - maximum number of attempts\n   * @param {Function} callback\n   */\n\n\n  SpeechToTextV1.prototype.whenCustomizationReady = function (params, callback) {\n    var self = this; // check the customization status repeatedly until it's ready or available\n\n    var options = extend({\n      interval: 5000,\n      times: 30\n    }, params, {\n      errorFilter: function errorFilter(err) {\n        // if it's a timeout error, then getLanguageModel is called again after params.interval\n        // otherwise the error is passed back to the user\n        // if the params.times limit is reached, the error will be passed to the user regardless\n        return err.code === SpeechToTextV1.ERR_TIMEOUT;\n      }\n    });\n    async.retry(options, function (next) {\n      self.getLanguageModel(params, function (err, res) {\n        var customization = err ? null : res.result;\n\n        if (err) {\n          next(err);\n        } else if (customization.status === 'pending' || customization.status === 'training') {\n          // if the loop times out, async returns the last error, which will be this one.\n          var sttError = new Error('Customization is still pending, try increasing interval or times params');\n          sttError.code = SpeechToTextV1.ERR_TIMEOUT;\n          next(sttError);\n        } else if (customization.status === 'ready' || customization.status === 'available') {\n          next(null, customization);\n        } else if (customization.status === 'failed') {\n          next(new Error('Customization training failed'));\n        } else {\n          next(new Error('Unexpected customization status: ' + customization.status));\n        }\n      });\n    }, callback);\n  };\n\n  SpeechToTextV1.ERR_NO_CORPORA = 'ERR_NO_CORPORA';\n  SpeechToTextV1.ERR_TIMEOUT = 'ERR_TIMEOUT';\n  return SpeechToTextV1;\n}(GeneratedSpeechToTextV1);\n\nmodule.exports = SpeechToTextV1;","map":null,"metadata":{},"sourceType":"script"}